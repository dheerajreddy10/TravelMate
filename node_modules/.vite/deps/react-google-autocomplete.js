import {
  require_prop_types
} from "./chunk-Z57WBPVW.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// node_modules/react-google-autocomplete/lib/utils.js
var require_utils = __commonJS({
  "node_modules/react-google-autocomplete/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.loadGoogleMapScript = exports.isBrowser = void 0;
    var isBrowser = typeof window !== "undefined" && window.document;
    exports.isBrowser = isBrowser;
    var loadGoogleMapScript = function loadGoogleMapScript2(googleMapsScriptBaseUrl, googleMapsScriptUrl) {
      if (!isBrowser) return Promise.resolve();
      if (typeof google !== "undefined") {
        if (google.maps && google.maps.api) return Promise.resolve();
      }
      var scriptElements = document.querySelectorAll('script[src*="'.concat(googleMapsScriptBaseUrl, '"]'));
      if (scriptElements && scriptElements.length) {
        return new Promise(function(resolve) {
          if (typeof google !== "undefined") return resolve();
          scriptElements[0].addEventListener("load", function() {
            return resolve();
          });
        });
      }
      var scriptUrl = new URL(googleMapsScriptUrl);
      scriptUrl.searchParams.set("callback", "__REACT_GOOGLE_AUTOCOMPLETE_CALLBACK__");
      var el = document.createElement("script");
      el.src = scriptUrl.toString();
      return new Promise(function(resolve) {
        window.__REACT_GOOGLE_AUTOCOMPLETE_CALLBACK__ = resolve;
        document.body.appendChild(el);
      });
    };
    exports.loadGoogleMapScript = loadGoogleMapScript;
  }
});

// node_modules/react-google-autocomplete/lib/constants.js
var require_constants = __commonJS({
  "node_modules/react-google-autocomplete/lib/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.GOOGLE_MAP_SCRIPT_BASE_URL = void 0;
    var GOOGLE_MAP_SCRIPT_BASE_URL = "https://maps.googleapis.com/maps/api/js";
    exports.GOOGLE_MAP_SCRIPT_BASE_URL = GOOGLE_MAP_SCRIPT_BASE_URL;
  }
});

// node_modules/react-google-autocomplete/lib/usePlacesWidget.js
var require_usePlacesWidget = __commonJS({
  "node_modules/react-google-autocomplete/lib/usePlacesWidget.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = usePlacesWidget;
    var _react = _interopRequireWildcard(require_react());
    var _utils = require_utils();
    var _constants = require_constants();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
      return target;
    }
    function usePlacesWidget(props) {
      var ref = props.ref, onPlaceSelected = props.onPlaceSelected, apiKey = props.apiKey, _props$libraries = props.libraries, libraries = _props$libraries === void 0 ? "places" : _props$libraries, _props$inputAutocompl = props.inputAutocompleteValue, inputAutocompleteValue = _props$inputAutocompl === void 0 ? "new-password" : _props$inputAutocompl, _props$options = props.options;
      _props$options = _props$options === void 0 ? {} : _props$options;
      var _props$options$types = _props$options.types, types = _props$options$types === void 0 ? ["(cities)"] : _props$options$types, componentRestrictions = _props$options.componentRestrictions, _props$options$fields = _props$options.fields, fields = _props$options$fields === void 0 ? ["address_components", "geometry.location", "place_id", "formatted_address"] : _props$options$fields, bounds = _props$options.bounds, options = _objectWithoutProperties(_props$options, ["types", "componentRestrictions", "fields", "bounds"]), _props$googleMapsScri = props.googleMapsScriptBaseUrl, googleMapsScriptBaseUrl = _props$googleMapsScri === void 0 ? _constants.GOOGLE_MAP_SCRIPT_BASE_URL : _props$googleMapsScri, language = props.language;
      var inputRef = (0, _react.useRef)(null);
      var event = (0, _react.useRef)(null);
      var autocompleteRef = (0, _react.useRef)(null);
      var observerHack = (0, _react.useRef)(null);
      var languageQueryParam = language ? "&language=".concat(language) : "";
      var googleMapsScriptUrl = "".concat(googleMapsScriptBaseUrl, "?libraries=").concat(libraries, "&key=").concat(apiKey).concat(languageQueryParam);
      var handleLoadScript = (0, _react.useCallback)(function() {
        return (0, _utils.loadGoogleMapScript)(googleMapsScriptBaseUrl, googleMapsScriptUrl);
      }, [googleMapsScriptBaseUrl, googleMapsScriptUrl]);
      (0, _react.useEffect)(function() {
        var config = _objectSpread(_objectSpread({}, options), {}, {
          fields,
          types,
          bounds
        });
        if (componentRestrictions) {
          config.componentRestrictions = componentRestrictions;
        }
        if (autocompleteRef.current || !inputRef.current || !_utils.isBrowser) return;
        if (ref && !ref.current) ref.current = inputRef.current;
        var handleAutoComplete = function handleAutoComplete2() {
          var _google$maps;
          if (typeof google === "undefined") return console.error("Google has not been found. Make sure your provide apiKey prop.");
          if (!((_google$maps = google.maps) !== null && _google$maps !== void 0 && _google$maps.places)) return console.error("Google maps places API must be loaded.");
          if (!inputRef.current instanceof HTMLInputElement) return console.error("Input ref must be HTMLInputElement.");
          autocompleteRef.current = new google.maps.places.Autocomplete(inputRef.current, config);
          if (autocompleteRef.current) {
            event.current = autocompleteRef.current.addListener("place_changed", function() {
              if (onPlaceSelected && autocompleteRef && autocompleteRef.current) {
                onPlaceSelected(autocompleteRef.current.getPlace(), inputRef.current, autocompleteRef.current);
              }
            });
          }
        };
        if (apiKey) {
          handleLoadScript().then(function() {
            return handleAutoComplete();
          });
        } else {
          handleAutoComplete();
        }
        return function() {
          return event.current ? event.current.remove() : void 0;
        };
      }, []);
      (0, _react.useEffect)(function() {
        var _React$version;
        if (!(_react.default !== null && _react.default !== void 0 && (_React$version = _react.default.version) !== null && _React$version !== void 0 && _React$version.startsWith("18")) && _utils.isBrowser && window.MutationObserver && inputRef.current && inputRef.current instanceof HTMLInputElement) {
          observerHack.current = new MutationObserver(function() {
            observerHack.current.disconnect();
            if (inputRef.current) {
              inputRef.current.autocomplete = inputAutocompleteValue;
            }
          });
          observerHack.current.observe(inputRef.current, {
            attributes: true,
            attributeFilter: ["autocomplete"]
          });
        }
      }, [inputAutocompleteValue]);
      (0, _react.useEffect)(function() {
        if (autocompleteRef.current) {
          autocompleteRef.current.setFields(fields);
        }
      }, [fields]);
      (0, _react.useEffect)(function() {
        if (autocompleteRef.current) {
          autocompleteRef.current.setBounds(bounds);
        }
      }, [bounds]);
      (0, _react.useEffect)(function() {
        if (autocompleteRef.current) {
          autocompleteRef.current.setComponentRestrictions(componentRestrictions);
        }
      }, [componentRestrictions]);
      (0, _react.useEffect)(function() {
        if (autocompleteRef.current) {
          autocompleteRef.current.setOptions(options);
        }
      }, [options]);
      return {
        ref: inputRef,
        autocompleteRef
      };
    }
  }
});

// node_modules/react-google-autocomplete/lib/ReactGoogleAutocomplete.js
var require_ReactGoogleAutocomplete = __commonJS({
  "node_modules/react-google-autocomplete/lib/ReactGoogleAutocomplete.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _usePlacesWidget2 = _interopRequireDefault(require_usePlacesWidget());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
      return target;
    }
    function ReactGoogleAutocomplete(props) {
      var onPlaceSelected = props.onPlaceSelected, apiKey = props.apiKey, libraries = props.libraries, inputAutocompleteValue = props.inputAutocompleteValue, options = props.options, googleMapsScriptBaseUrl = props.googleMapsScriptBaseUrl, refProp = props.refProp, language = props.language, rest = _objectWithoutProperties(props, ["onPlaceSelected", "apiKey", "libraries", "inputAutocompleteValue", "options", "googleMapsScriptBaseUrl", "refProp", "language"]);
      var _usePlacesWidget = (0, _usePlacesWidget2.default)({
        ref: refProp,
        googleMapsScriptBaseUrl,
        onPlaceSelected,
        apiKey,
        libraries,
        inputAutocompleteValue,
        options,
        language
      }), ref = _usePlacesWidget.ref;
      return _react.default.createElement("input", _extends({
        ref
      }, rest));
    }
    ReactGoogleAutocomplete.propTypes = {
      apiKey: _propTypes.default.string,
      libraries: _propTypes.default.arrayOf(_propTypes.default.string),
      ref: _propTypes.default.oneOfType([
        // Either a function
        _propTypes.default.func,
        // Or anything shaped { current: any }
        _propTypes.default.shape({
          current: _propTypes.default.any
        })
      ]),
      googleMapsScriptBaseUrl: _propTypes.default.string,
      onPlaceSelected: _propTypes.default.func,
      inputAutocompleteValue: _propTypes.default.string,
      options: _propTypes.default.shape({
        componentRestrictions: _propTypes.default.object,
        bounds: _propTypes.default.object,
        location: _propTypes.default.object,
        offset: _propTypes.default.number,
        origin: _propTypes.default.object,
        radius: _propTypes.default.number,
        sessionToken: _propTypes.default.object,
        types: _propTypes.default.arrayOf(_propTypes.default.string)
      }),
      language: _propTypes.default.string
    };
    var _default = (0, _react.forwardRef)(function(props, ref) {
      return _react.default.createElement(ReactGoogleAutocomplete, _extends({}, props, {
        refProp: ref
      }));
    });
    exports.default = _default;
  }
});

// node_modules/react-google-autocomplete/lib/index.js
var require_lib = __commonJS({
  "node_modules/react-google-autocomplete/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function get() {
        return _ReactGoogleAutocomplete.default;
      }
    });
    Object.defineProperty(exports, "usePlacesWidget", {
      enumerable: true,
      get: function get() {
        return _usePlacesWidget.default;
      }
    });
    var _ReactGoogleAutocomplete = _interopRequireDefault(require_ReactGoogleAutocomplete());
    var _usePlacesWidget = _interopRequireDefault(require_usePlacesWidget());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// node_modules/react-google-autocomplete/index.js
var require_react_google_autocomplete = __commonJS({
  "node_modules/react-google-autocomplete/index.js"(exports, module) {
    module.exports = require_lib();
  }
});
export default require_react_google_autocomplete();
//# sourceMappingURL=react-google-autocomplete.js.map
